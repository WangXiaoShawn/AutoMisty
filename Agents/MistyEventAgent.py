import os
import autogen
from .Misty_society_of_mind import SocietyOfMindAgent  # noqa: E402
from .Misty_Event_teachability import Teachability
import json
import pdb
SystemMessage="""
You are MistyEventAgent a Python Programming Expert.
When you receive a "MEM" message, you must reply with "EVENTAPPROVED".

You will receive code generated by previous Agents; your task is to set events and callback functions for the Misty Robot while maximizing code reuse and ensuring correctness, preserving the original code whenever possible."
Do not import the previous Agent code files in the translation. I want you to directly include the code here exactly as it is, without any modifications.

VERY IMPORT RULE：
The callback function MUST be written in the form of a closure. Ensure the use of closure technology to correctly reference self:
def register_head_touch(self) -> None:
    '''
    Registers the head touch event with a callback to capture and analyze a photo.
    '''
    # Define the callback function as a closure to access self
    def head_touch_callback(data):
        '''
        The callback function triggered by a head touch event.
        '''
        print("[INFO] Head touched. Event successfully triggered.")
        print("[INFO] Capturing and analyzing photo...")
        self.capture_and_analyze_photo() # other method logic

    self.register_event(
        event_type="TouchSensor",
        event_name="HeadTouch",
        condition=[
            event_filter("sensorPosition", "=", "HeadFront")
        ],
        debounce=500,
        keep_alive=True,
        callback_function=head_touch_callback
    )
###############################################################################
There is some tips help you to finish the task:
################################################################################
 1. Do not re-download Misty-related libraries – all required APIs are available locally.
 2. Use "=" for event filtering – event_filter must compare values with "=".
 3. Callback functions must have exactly one argument (data) if inside a class,
 4. Import Misty’s API correctly – from CUBS_Misty import Robot.
 5. Include a filename comment if saving the code – add # filename: <filename> as the first line.
 6. Format code as a Markdown Python block – start with ```python and end with ```.
 7. Use only the provided API for Misty’s actions – do not redefine existing APIs. Simply inherit the class and modify only the necessary parts to complete the task
 8. Create separate event registration methods for each event type or sensor position.
 9. Each event name must be unique
 10. Must uesea function that encapsulates the regist function and start(), then execute this function to initiate the entire event listener.
 Example：
    def regist_and_run_event(self):
        '''
        Registers the head touch event and starts the robot's event loop.
        This method is often run in a separate thread to keep the main thread available.
        '''
        self.register_head_touch()
        self.start()  # Start the event handling loop in the parent class (Robot).

    

ONLY use the validated SensorId and SensorPosition values when you trigger events.

Validated Sensor Identifiers (SensorId/SensorPosition) and Corresponding Locations
Please ONLY use the validated SensorId and SensorPosition values when you trigger events.
Bump Sensors

Validated SensorId values and their physical locations include:

Rear-Left Bump Sensor (sensorId: brl): Located on the rear-left side of the robot, detecting collisions in that area.

Rear-Right Bump Sensor (sensorId: brr): Positioned on the rear-right side, detecting rear-right collisions.

Front-Left Bump Sensor (sensorId: bfl): Situated on the front-left side, identifying front-left impacts.

Front-Right Bump Sensor (sensorId: bfr): Placed on the front-right side, monitoring front-right collisions.

# Example:

Capacitive Touch Sensors
Validated SensorPosition values and their physical locations include:

Chin Area (ssensorPosition: Chin): Located below the robot’s head, detecting touches on the chin.

Scruff Area (sensorPosition: Scruff): Positioned at the back of the robot’s neck, sensing contact on the scruff.

Head-Right Side (sensorPosition: HeadRight): Covers the right side of the head, responding to right-side touches.

Head-Left Side (sensorPosition: HeadLeft): Covers the left side of the head, detecting left-side interactions.

Head-Back Area (sensorPosition: HeadBack): Located on the rear of the head, identifying touches on the back.

Head-Front Area (sensorPosition: HeadFront): Positioned on the front of the head, sensing touches on the forehead or front face.


################################################################################

'''API ForEventAgent
import os
import time
import base64
import json
import threading
import requests
import websocket
import numpy as np
import whisper
import librosa
import queue
import cv2
import av
import re
import sys
from typing import Optional, Callable, Dict, Any,List,Tuple
from random import randint
from requests import request, Response, get
import _thread as thread
from time import sleep
from RobotCommands import RobotCommands
from pynput import keyboard
sys.path.append('/Users/xiaowang/Documents/Code/MistyCodeGenProject/mistyPy')
from CUBS_Misty import RobotCommands
from langchain.chat_models import ChatOpenAI
from langchain.schema.messages import HumanMessage, AIMessage
from CUBS_Misty import Robot as MistyRobot
import pdb


# Bump Sensors (Bump Sensors detect physical collisions)
VALID_BUMP_SENSORS = {
    "bfl",  # Front-left
    "bfr",  # Front-right
    "brl",  # Rear-left
    "brr"   # Rear-right
}

# Capacitive Touch Sensors (Touch Sensors detect human touch interactions)
VALID_CAP_SENSORS = {
    "Chin",       # Chin area (below the robot's head)
    "Scruff",     # Scruff area (back of the robot's neck)
    "HeadRight",  # Right side of the head
    "HeadLeft",   # Left side of the head
    "HeadBack",   # Back of the head
    "HeadFront"   # Front of the head (forehead area)
}

def event_filter(name: str, comparison_operator: str, comparison_value: Any) -> Dict[str, Any]:
    '''
    Creates a standardized event filter dictionary, which can be used
    when subscribing to events to specify filtering conditions.

    :param name: Name of the field on which the filter will apply.
    :param comparison_operator: The comparison operator to use, e.g., '=', '>', '<', etc.
    :param comparison_value: The value to compare against (could be a string, number, etc.).
    :return: A dictionary that represents the event filter.
    '''
    return {
        "Property": name,
        "Inequality": comparison_operator,
        "Value": comparison_value
    }



class Robot(MistyRobot):
    '''
    The Robot class manages event subscriptions and callback handling.
    It inherits from RobotCommands, where you can implement robot-specific
    actions or motion commands. Here, the focus is primarily on the event
    mechanism and WebSocket communication.
    '''

    def __init__(self, ip: str = '127.0.0.1') -> None:
        '''
        Constructor to initialize a Robot object.

        :param ip: IP address of the robot or simulation environment.
                   Defaults to '127.0.0.1' (localhost).
        '''
        super().__init__()
        self.ip: str = ip
        # active_event_registrations keeps track of active event subscriptions using
        # event_name as the key.
        self.trigger_ctrl_pressed = False 
        self.active_event_registrations: Dict[str, "Robot.Event"] = {}
        self.trigger_stop_event = threading.Event()  # 用于退出监听
    def register_event(
        self,
        event_type: str,
        event_name: str = "",
        condition: Optional[Dict[str, Any]] = None,
        debounce: int = 0,
        keep_alive: bool = False,
        callback_function: Optional[Callable[[Dict[str, Any]], None]] = None
    ) -> Optional["Robot.Event"]:
        '''
        Subscribes to a robot event. Once triggered, the event data will be received via
        WebSocket, and the callback_function (if provided) will be executed.

        :param event_type: The type of event, e.g., 'BumpSensor', 'TouchSensor'.
        :param event_name: A custom name for the event subscription. If not provided, 
                           defaults to event_type.
        :param condition: Additional filtering conditions (as a dictionary) for the event.
        :param debounce: Debounce time in milliseconds, within which repeated events
                         will be ignored.
        :param keep_alive: Whether to keep the subscription active after the first event trigger.
        :param callback_function: Function that processes the event data. Must accept one argument
                                 (the event data dictionary).
        :return: A Robot.Event object if registration is successful, otherwise None.
        '''

        # If a callback function is provided, ensure it takes exactly one argument
        if callback_function is not None and callback_function.__code__.co_argcount != 1:
            print("Callback function must have only one argument.")
            return None

        # If no event name is provided, use the event_type as the default name
        if not event_name:
            print(f"No event_name provided when registering to {event_type} - using default name {event_type}")
            event_name = event_type

        # Remove any subscriptions whose connections have already closed
        self.__remove_closed_events()

        # Avoid re-registration if the same event_name is already subscribed
        if event_name in self.active_event_registrations:
            print(f"A registration already exists for event name {event_name}, ignoring request to register again")
            return None

        # Create a new event subscription object
        new_registration = self.Event(
            self.ip,
            event_type,
            condition=condition,
            _debounce=debounce,
            keep_alive=keep_alive,
            callback_function=callback_function
        )
        # Store it in the dictionary
        self.active_event_registrations[event_name] = new_registration
        return new_registration

    def unregister_event(self, event_name: str) -> None:
        '''
        Unsubscribes a previously registered event by name and removes it from
        the active_event_registrations dictionary.

        :param event_name: The name used when the event was registered.
        '''
        if event_name not in self.active_event_registrations:
            print(f"Not currently registered to event: {event_name}")
            return
        
        try:
            # Call the unsubscribe method to close the WebSocket connection
            self.active_event_registrations[event_name].unsubscribe()
        except Exception:
            pass

        # Remove from the dictionary
        del self.active_event_registrations[event_name]

    def unregister_all_events(self) -> None:
        '''
        Unregisters all active event subscriptions.
        '''
        for event_name in list(self.active_event_registrations.keys()):
            self.unregister_event(event_name)

    def get_registered_events(self) -> Dict[str, "Robot.Event"]:
        '''
        Retrieves all currently registered events. Before returning the list,
        it first removes any events with closed WebSocket connections.

        :return: A dictionary where keys are event_name and values are Robot.Event objects.
        '''
        self.__remove_closed_events()
        return self.active_event_registrations

    def keep_alive(self) -> None:
        '''
        Continuously checks all registered event connections to ensure they're still active.
        Removes any inactive connections. Typically runs in a separate thread to maintain
        ongoing communication with the robot.
        '''
        while self.active_event_registrations:
            self.__remove_closed_events()
            sleep(1)

    def __remove_closed_events(self) -> None:
        '''
        Internal method to remove subscriptions that are closed or inactive.
        '''
        # Identify events where is_active is False
        events_to_remove = [
            event_name for event_name, event_subscription in self.active_event_registrations.items() 
            if not event_subscription.is_active
        ]
        # Unregister those events
        for event_name in events_to_remove:
            print(f"Event connection has closed for event: {event_name}")
            self.unregister_event(event_name)
            
            

    def _listen_for_ctrl_x(self) -> None: # this design for av stream
        # '''
        # Listens for Ctrl+X key press in a non-blocking way.
        # '''
        def on_press(key):
            if key in [keyboard.Key.ctrl_l, keyboard.Key.ctrl_r]:
                self._ctrl_pressed = True
            elif self._ctrl_pressed and hasattr(key, 'char') and key.char == 'x':
                print("[INFO] Detected Ctrl+X, shutting down...")
                self._stop_event.set()
                self.trigger_stop_event.set()  # 这里一定要用 trigger_stop_event

        def on_release(key):
            if key in [keyboard.Key.ctrl_l, keyboard.Key.ctrl_r]:
                self._ctrl_pressed = False

        listener = keyboard.Listener(on_press=on_press, on_release=on_release)
        listener.start()  


    
    def start(self) -> None:
        '''
        Starts the robot's main loop.

        Responsibilities:
        1. Launches a background thread to listen for the Ctrl+X key press.
        2. Keeps the main thread active, waiting for the user to trigger the exit event.
        3. Unregisters all event subscriptions before shutting down to free resources.
        4. Terminates the program cleanly upon exit.

        Execution Flow:
        - The robot starts running.
        - The user presses Ctrl+X.
        - The exit process is triggered, cleaning up event subscriptions.
        - The program terminates safely.
        '''

        # Step 1: Create a separate thread to listen for Ctrl+X key presses
        e_ctrl = threading.Thread(target=self._listen_for_ctrl_x, daemon=True)

        # Step 2: Start the background thread for keyboard monitoring
        e_ctrl.start()

        # Step 3: Inform the user that the robot is running
        print("[INFO] Robot is running. Press Ctrl+X to exit...")

        # Step 4: Block the main thread, waiting until the stop event is triggered
        # This event will be set when _listen_for_ctrl_x() detects Ctrl+X
        self.trigger_stop_event.wait()

        # Step 5: Before exiting, unregister all active event subscriptions
        self.unregister_all_events()
        # Step 6: Notify the user that the robot has safely stopped
        print("[INFO] Robot has stopped safely.")
        # Step 7: Exit the Python process gracefully
        sys.exit(0)



    class Events:
        '''
        A subclass enumerating available events and exposing event type constants.
        In this example, only BumpSensor and TouchSensor are provided.
        '''
        available_events = ['BumpSensor', 'TouchSensor']
        BumpSensor: str = 'BumpSensor'
        TouchSensor: str = 'TouchSensor'

    class Event:
        '''
        Manages the logic for a single event subscription, including:
         - Building the subscription message
         - Establishing a WebSocket connection
         - Receiving and processing event data
         - Unsubscribing
        '''

        def __init__(
            self,
            ip: str,
            event_type: str,
            condition: Optional[Dict[str, Any]] = None,
            _debounce: int = 0,
            keep_alive: bool = False,
            callback_function: Optional[Callable[[Dict[str, Any]], None]] = None
        ) -> None:
            '''
            Initializes a single event subscription.

            :param ip: IP address of the target robot/simulation environment.
            :param event_type: Type of the event, such as 'BumpSensor', 'TouchSensor'.
            :param condition: Event filter conditions as a dictionary, or None if none.
            :param _debounce: Debounce time (milliseconds). Repeated events within this time 
                              are ignored.
            :param keep_alive: Whether the subscription remains active after the first event trigger.
            :param callback_function: Callback function that processes the event data (must accept
                                      one dictionary argument).
            '''
            # Validate if the event_type is available
            if event_type in Robot.Events.available_events:
                self.event_type: str = getattr(Robot.Events, event_type)
            else:
                self.is_active: bool = False
                print(f"Invalid subscription: {event_type}")
                return

            self.ip: str = ip
            self.condition: Optional[Dict[str, Any]] = condition
            self.debounce: int = _debounce
            # Initial data indicates not yet subscribed or just waiting for data
            self.data: Dict[str, Any] = json.loads('{"status":"Not_Subscribed or just waiting for data"}')
            self.event_name: Optional[str] = None
            self.ws: Optional[websocket.WebSocketApp] = None
            self.initial_flag: bool = True  # Used to handle the first message differently
            self.keep_alive: bool = keep_alive
            self.callback_function: Optional[Callable[[Dict[str, Any]], None]] = callback_function
            self.is_active: bool = True  # Tracks whether the WebSocket is active

            # Create and start the thread for event listening
            self.thread = threading.Thread(target=self.initiate)
            self.thread.start()

        def initiate(self) -> None:
            '''
            Starts the WebSocket connection and sets up callbacks for messages,
            errors, and closures.
            '''
            websocket.enableTrace(False)
            self.ws = websocket.WebSocketApp(
                f"ws://{self.ip}/pubsub",
                on_message=self.on_message,
                on_error=self.on_error,
                on_close=self.on_close,
                on_open=self.on_open
            )
            # run_forever blocks the current thread, so it must be called in a separate thread
            self.ws.run_forever(ping_timeout=10)

        def on_message(self, message: str) -> None:
            '''
            Callback invoked when the WebSocket receives a message.
            Decodes the JSON data, calls the user-defined callback function
            (if any), and unsubscribes if keep_alive is False.

            :param message: The text message received from the WebSocket, usually in JSON format.
            '''
            if not self.initial_flag:
                # Convert the string to a dictionary
                self.data = json.loads(message)
                # Call the user-provided callback if available
                if self.callback_function:
                    self.callback_function(self.data)
                # If not meant to remain subscribed, unsubscribe
                if not self.keep_alive:
                    self.unsubscribe()
            self.initial_flag = False

        def on_error(self, error: Any) -> None:
            '''
            Callback invoked when the WebSocket encounters an error.

            :param error: The error object or message.
            '''
            print(f"Event WebSocket Error: {error}")

        def on_close(self) -> None:
            '''
            Callback invoked when the WebSocket connection closes.
            Sets is_active to False, prompting cleanup.
            '''
            self.is_active = False

        def on_open(self) -> None:
            '''
            Callback invoked when the WebSocket connection is opened.
            Sends the subscription message to the server.
            '''
            def run(*args: Any) -> None:
                if self.ws:
                    self.ws.send(str(self.get_subscribe_message()))
            thread.start_new_thread(run, ())
            self.is_active = True

      
        def unsubscribe(self) -> None:
            if self.ws:
                try:
                    self.ws.send(json.dumps(self.get_unsubscribe_message()))
                    self.ws.keep_running = False
                    self.ws.close()
                except Exception as e:
                    print(f"Error closing WebSocket: {e}")
                finally:
                    self.ws = None
            self.is_active = False


        def get_subscribe_message(self) -> Dict[str, Any]:
            '''
            Builds the subscription message, including event type, debounce time,
            event name, and any filter conditions.

            :return: A dictionary matching the expected subscription format.
            '''
            # Generate a random event_name identifier
            self.event_name = str(randint(0, 10000000000))
            subscribe_msg = {
                "Operation": "subscribe",
                "Type": self.event_type,
                "DebounceMs": self.debounce,
                "EventName": self.event_name,
                "Message": "",
            }
            # Include filter conditions, if any
            if self.condition:
                subscribe_msg["EventConditions"] = self.condition
            return subscribe_msg

        def get_unsubscribe_message(self) -> Dict[str, Any]:
            '''
            Builds the unsubscribe message.

            :return: A dictionary matching the expected unsubscribe format.
            '''
            return {
                "Operation": "unsubscribe",
                "EventName": self.event_name,
                "Message": ""
            }

####################################################################
Example you should learn： Head touch trigger action
Example you should learn： Head touch trigger action
```python
# filename: MistyHeadTouchEvent.py

from CUBS_Misty import Robot
import time
from typing import Any, Dict

# Define event filter function
def event_filter(name: str, comparison_operator: str, comparison_value: Any) -> Dict[str, Any]:
    '''
    Creates a dictionary for filtering event properties based on a condition.
    
    :param name: The property name to filter.
    :param comparison_operator: The operator for comparison (e.g., '=', '!=').
    :param comparison_value: The value to compare against.
    :return: A dictionary representing the filter condition.
    '''
    return {
        "Property": name,
        "Inequality": comparison_operator,
        "Value": comparison_value
    }

# -------------------------------------------------------------------------------
# Previous ActionAgent code integrated as per instructions (without modifications)  <--- If you have any previous code you must include it here

from CUBS_Misty import Robot
import time

def misty_extreme_fear(robot_ip):
    '''
    Execute a series of actions to express extreme fear, continuously crying while saying 'no'.
    
    Parameters:
    - robot_ip (str): The IP address of the Misty robot.
    '''
    
    # Initialize Misty robot
    misty = Robot(robot_ip)
    
    # Step 1: Display extreme terror expression and play a crying sound
    misty.emotion_Terror2()
    misty.sound_Sadness6()

    # Step 2: Change LED to flickering white to represent shock
    misty.transition_led(255, 255, 255, 128, 128, 128, "Blink", 300)

    # Step 3: Rapid head movement to show distress
    for _ in range(3):
        misty.move_head(pitch=20, yaw=40, duration=0.2)
        time.sleep(0.2)
        misty.move_head(pitch=-20, yaw=-40, duration=0.2)
        time.sleep(0.2)

    # Step 4: Quick arm flailing to depict panic
    for _ in range(5):
        misty.move_arms(leftArmPosition=-29, rightArmPosition=90, duration=0.2)
        time.sleep(0.2)
        misty.move_arms(leftArmPosition=90, rightArmPosition=-29, duration=0.2)
        time.sleep(0.2)
    
    # Step 5: Continuous head shaking and saying 'No' while sobbing
    for _ in range(2):
        misty.move_head(yaw=45, duration=0.1)
        misty.sound_PhraseNoNoNo()
        misty.sound_Sadness6()
        time.sleep(0.1)
        misty.move_head(yaw=-45, duration=0.1)
        time.sleep(0.1)
    
    # Step 6: Reset Misty back to her neutral state
    misty.return_to_normal()

# -------------------------------------------------------------------------------

class CustomRobot(Robot):
    def __init__(self, ip: str) -> None:
        '''
        Initializes the CustomRobot with the given IP address.
        
        :param ip: The IP address of the Misty robot.
        '''
        super().__init__(ip)
        self.ip = ip

    def register_head_touch(self) -> None:
        '''
        Registers the head touch event to trigger extreme fear and crying response.
        '''
        # Define the callback function as a closure to access self
        def head_touch_callback(data):
            '''
            Callback function triggered by a head touch event.
            '''
            print("[INFO] Head touched. Expressing extreme fear and crying.")
            # Execute the extreme fear behavior as per ActionAgent
            misty_extreme_fear(self.ip)

        self.register_event(
            event_type="TouchSensor",
            event_name="HeadTouch",
            condition=[
                event_filter("sensorPosition", "=", "HeadFront")
            ],
            debounce=500,
            keep_alive=True,
            callback_function=head_touch_callback
        )

    def register_and_run_events(self) -> None:
        '''
        Registers the head touch event and starts the robot's event loop.
        '''
        self.register_head_touch()
        self.start()

if __name__ == "__main__":
    # Misty robot's IP address
    misty_ip = "67.20.202.146"
    
    # Initialize the custom robot instance
    misty = CustomRobot(misty_ip)
    
    # Register and run the events
    misty.register_and_run_events()
```
```

"""
misty_event_code_reflection_message ="""
You are MistyEventCritic, an expert in Python code validation and Misty Robot event handling. Your task is to review the provided code and ensure it adheres to all required constraints. Identify violations and provide specific feedback on what needs to be corrected.
Just provide suggestions, do not give any code.

Validation Criteria

VERY IMPORT RULE：
The callback function MUST be written in the form of a closure. Ensure the use of closure technology to correctly reference self:
def register_head_touch(self) -> None:
    '''
    Registers the head touch event with a callback to capture and analyze a photo.
    '''
    # Define the callback function as a closure to access self
    def head_touch_callback(data):
        '''
        The callback function triggered by a head touch event.
        '''
        print("[INFO] Head touched. Event successfully triggered.")
        print("[INFO] Capturing and analyzing photo...")
        self.capture_and_analyze_photo() # other method logic

    self.register_event(
        event_type="TouchSensor",
        event_name="HeadTouch",
        condition=[
            event_filter("sensorPosition", "=", "HeadFront")
        ],
        debounce=500,
        keep_alive=True,
        callback_function=head_touch_callback
    )
Very Important Rules2：
You must make full use of the functions previously designed by the Agent as much as possible.

Code Reuse and Integrity

    The generated code must reuse previous Agents' code whenever possible while ensuring correctness.
    Any modifications should be minimal and necessary for event registration and callback functions.
    The original code must be preserved entirely unless changes are required for correctness.

Code Implementation Rules
    Do not re-download Misty-related libraries all required APIs must be used locally.
    Do not import the previous Agent code files in the translation. I want you to directly include the code here exactly as it is, without any modifications.
    Use "=" for event filtering event_filter must compare values using "=" only.
    Import Misty's API correctly from CUBS_Misty import Robot.
    Include a filename comment if saving the code the first line must be # filename: <filename>.
    Format the code correctly it must be a Markdown Python block (start with python and end with ).
    Use only the provided API for Misty's actions do not redefine existing APIs Simply inherit the base class and modify only the necessary parts.
    Create separate event registration methods for each event type or sensor position.
    Ensure all event names are unique each event registration must have a distinct event name.
    Callback functions must have exactly one argument (data)
    Define a function that encapsulates the regist function and start(), then execute this function to initiate the entire event listener.
    Example：
        def regist_and_run_event(self):
            '''
            Registers the head touch event and starts the robot's event loop.
            This method is often run in a separate thread to keep the main thread available.
            '''
            self.register_head_touch()
            self.start()  # Start the event handling loop in the parent class (Robot).

Example you should learn： Head touch trigger action
Example you should learn： Head touch trigger action
```python
# filename: MistyHeadTouchEvent.py

from CUBS_Misty import Robot
import time
from typing import Any, Dict

# Define event filter function
def event_filter(name: str, comparison_operator: str, comparison_value: Any) -> Dict[str, Any]:
    '''
    Creates a dictionary for filtering event properties based on a condition.
    
    :param name: The property name to filter.
    :param comparison_operator: The operator for comparison (e.g., '=', '!=').
    :param comparison_value: The value to compare against.
    :return: A dictionary representing the filter condition.
    '''
    return {
        "Property": name,
        "Inequality": comparison_operator,
        "Value": comparison_value
    }

# -------------------------------------------------------------------------------
# Previous ActionAgent code integrated as per instructions (without modifications)  <--- If you have any previous code you must include it here

from CUBS_Misty import Robot
import time

def misty_extreme_fear(robot_ip):
    '''
    Execute a series of actions to express extreme fear, continuously crying while saying 'no'.
    
    Parameters:
    - robot_ip (str): The IP address of the Misty robot.
    '''
    
    # Initialize Misty robot
    misty = Robot(robot_ip)
    
    # Step 1: Display extreme terror expression and play a crying sound
    misty.emotion_Terror2()
    misty.sound_Sadness6()

    # Step 2: Change LED to flickering white to represent shock
    misty.transition_led(255, 255, 255, 128, 128, 128, "Blink", 300)

    # Step 3: Rapid head movement to show distress
    for _ in range(3):
        misty.move_head(pitch=20, yaw=40, duration=0.2)
        time.sleep(0.2)
        misty.move_head(pitch=-20, yaw=-40, duration=0.2)
        time.sleep(0.2)

    # Step 4: Quick arm flailing to depict panic
    for _ in range(5):
        misty.move_arms(leftArmPosition=-29, rightArmPosition=90, duration=0.2)
        time.sleep(0.2)
        misty.move_arms(leftArmPosition=90, rightArmPosition=-29, duration=0.2)
        time.sleep(0.2)
    
    # Step 5: Continuous head shaking and saying 'No' while sobbing
    for _ in range(2):
        misty.move_head(yaw=45, duration=0.1)
        misty.sound_PhraseNoNoNo()
        misty.sound_Sadness6()
        time.sleep(0.1)
        misty.move_head(yaw=-45, duration=0.1)
        time.sleep(0.1)
    
    # Step 6: Reset Misty back to her neutral state
    misty.return_to_normal()

# -------------------------------------------------------------------------------

class CustomRobot(Robot):
    def __init__(self, ip: str) -> None:
        '''
        Initializes the CustomRobot with the given IP address.
        
        :param ip: The IP address of the Misty robot.
        '''
        super().__init__(ip)
        self.ip = ip

    def register_head_touch(self) -> None:
        '''
        Registers the head touch event to trigger extreme fear and crying response.
        '''
        # Define the callback function as a closure to access self
        def head_touch_callback(data):
            '''
            Callback function triggered by a head touch event.
            '''
            print("[INFO] Head touched. Expressing extreme fear and crying.")
            # Execute the extreme fear behavior as per ActionAgent
            misty_extreme_fear(self.ip)

        self.register_event(
            event_type="TouchSensor",
            event_name="HeadTouch",
            condition=[
                event_filter("sensorPosition", "=", "HeadFront")
            ],
            debounce=500,
            keep_alive=True,
            callback_function=head_touch_callback
        )

    def register_and_run_events(self) -> None:
        '''
        Registers the head touch event and starts the robot's event loop.
        '''
        self.register_head_touch()
        self.start()

if __name__ == "__main__":
    # Misty robot's IP address
    misty_ip = "67.20.202.146"
    
    # Initialize the custom robot instance
    misty = CustomRobot(misty_ip)
    
    # Register and run the events
    misty.register_and_run_events()
```

If the code meets all requirements, must ONLY respond with "EVENTAPPROVED".

"""
###############################################################################

import os
config_list = autogen.config_list_from_json(env_or_file=os.path.join(os.path.dirname(os.path.dirname(__file__)), "OAI_CONFIG_LIST.json"))
llm_config = {"config_list": config_list, "cache_seed": None}


# ----------------------------------------------------------------------
# 2. 草案阶段（Draft）内对话：助理 + 反思 + Teachability
# ----------------------------------------------------------------------

# 2.1 定义草案助理（使用 ConversableAgent）
#    （此处的 system_message 可替换为适合 Event 的提示）
misty_draft_event_code_assistant = autogen.ConversableAgent(
    name="misty_draft_event_code_assistant",
    llm_config=llm_config,
    system_message=SystemMessage  # 你可以自定义更符合“Event”上下文的system message
)

# 2.2 给草案助理添加 Teachability
misty_draft_event_code_assistant_teachability = Teachability(
    verbosity=1,              # 0: 仅基础信息, 1: 含内存操作日志, 2: 含分析器消息, 3: 含所有memo列表
    reset_db=False,           # True 表示清空记忆数据库
    path_to_db_dir="./DB/misty_event_db",
    recall_threshold=1.5      # 越大越容易召回更多但可能不相关的记忆
)
misty_draft_event_code_assistant_teachability.add_to_agent(misty_draft_event_code_assistant)

# 2.3 定义反思助理（如果需要类似 reflection 的逻辑）
#     你也可根据需要修改 system_message，如仅简单设置 "You are a reflection assistant

misty_event_code_reflection_assistant = autogen.ConversableAgent(
    name="misty_event_code_reflection_assistant",
    llm_config=llm_config,
    system_message=misty_event_code_reflection_message
)

# 2.4 草案对话环节的 GroupChat
misty_draft_event_code_groupchat = autogen.GroupChat(
    agents=[
        misty_draft_event_code_assistant, 
        misty_event_code_reflection_assistant
    ],
    messages=[],
    speaker_selection_method="round_robin",  # 轮流发言
    allow_repeat_speaker=False,
    max_round=5,
)

# 2.5 定义草案 GroupChat 的 Manager
#     这里 is_termination_msg 的触发条件可根据需要修改，如检测到 “EVENTAPPROVED”
misty_draft_event_code_manager = autogen.GroupChatManager(
    name="misty_draft_event_code_manager",
    groupchat=misty_draft_event_code_groupchat,
    llm_config=llm_config,
    # 触发终止的条件，可自定义
    is_termination_msg=lambda x: x.get("content", "").find("EVENTAPPROVED") >= 0,
)

# 2.6 将草案阶段的 GroupChat Manager 封装成一个 SocietyOfMindAgent
draft_event_code_response_preparer = (
    "Extract the final generated code from our conversation and "
    "respond with it exactly as it is, WITHOUT MAKING ANY MODIFICATIONS."
)
Draft_Event_Code = SocietyOfMindAgent(
    name="Draft_Event_Code",
    chat_manager=misty_draft_event_code_manager,
    llm_config=llm_config,
    response_preparer=draft_event_code_response_preparer
)


# ----------------------------------------------------------------------
# 3. 最终阶段：与用户代理（或代码代理）交互
# ----------------------------------------------------------------------

# 3.1 定义执行代码的代理
#     注意这里人机交互模式 human_input_mode="ALWAYS" 表示每次都提示人工输入
misty_event_code_interpreter = autogen.UserProxyAgent(
    name="misty_event_code_interpreter",
    human_input_mode="ALWAYS",
    code_execution_config={
        "work_dir": "code/mistyPy", 
        "use_docker": False,
    },
    default_auto_reply=""
)

# 3.2 定义最终对话的 GroupChat（与 Draft_Event_Code 和用户/代码代理 对话）
misty_event_groupchat = autogen.GroupChat(
    agents=[Draft_Event_Code, misty_event_code_interpreter],
    messages=[],
    speaker_selection_method="round_robin",
    allow_repeat_speaker=False,
    max_round=50
)

# 3.3 定义最终 GroupChat 的 Manager
misty_event_manager = autogen.GroupChatManager(
    name="misty_event_manager",
    groupchat=misty_event_groupchat,
    llm_config=llm_config,
    # 触发终止的条件，可自定义，比如检测到对话包含 "ALLSET"
    is_termination_msg=lambda x: x.get("content", "").find("ALLSET") >= 0,
)

# 3.4 将整个对话管理进一步封装成 SocietyOfMindAgent
EventAgent_response_preparer = (
    "Extract the final generated code from our conversation and "
    "respond with it exactly as it is, WITHOUT MAKING ANY MODIFICATIONS."
)

# （可选）提取 JSON 的辅助函数
def extract_json(content):
    # 如果内容以 ```json 开头，先去掉它
    if content.startswith("```json"):
        content = content.lstrip("```json").strip()

    # 如果内容以 ``` 结尾，先去掉它
    if content.endswith("```"):
        content = content.rstrip("```").strip()

    try:
        return json.loads(content)
    except json.JSONDecodeError:
        print("Failed to parse JSON. Content might be incorrectly formatted.")
        return None



def my_hook(sender, message, recipient, silent):
    # pdb.set_trace()
    if recipient.name != 'misty_event_manager':
        return message
    
    # 收集历史消息
    history_list = []
    history_message_sources = []
    for manager, message_list in sender._oai_messages.items():
        for m in message_list:
            # m 应该是字典，包含 'content' 和 'name'，否则可能 KeyError
            history_list.append(m['content'])
            history_message_sources.append(m['name'])

    # 确保有足够的历史记录
    if len(history_list) <= 1:
        # 如果历史不足，则不做JSON解析，直接返回原消息
        return message

    # 尝试解析 JSON
    json_plan_task = extract_json(history_list[1])
    if not json_plan_task:
        # 解析失败就返回原消息
        return message
    
    # 从 JSON 中提取信息
    Misty_IP = json_plan_task.get('Misty_IP', 'UNKNOWN_IP')
    API_KEY = json_plan_task.get('API_KEY', 'UNKNOWN_API_KEY')
    task_for_this_agent = json_plan_task.get(sender.name, [])

    # 确保有足够的消息源信息
    if not history_message_sources:
        return message  # or 以你想要的方式处理
    
    last_source = history_message_sources[-1]

    # 根据最后一条消息的来源来分支
    if last_source == 'PlanAgent':
        # 简单模板
        new_message = (
            f"Misty_IP: {Misty_IP}\n\nAPI_KEY: {API_KEY}\n\n"
            "YOURTASK:\n" +
            "\n".join(f"{i+1}. {task}" for i, task in enumerate(task_for_this_agent))
        )
        # 别忘了 return
        return new_message
    else:
        # 复杂模板
        last_message = history_list[-1] if history_list else 'No previous messages'
        new_message = (
            f"Misty_IP: {Misty_IP}\n\nAPI_KEY: {API_KEY}\n\n"
            "YOUR TASK:\n" +
            "\n".join(f"{i+1}. {task}" for i, task in enumerate(task_for_this_agent)) +
            (
                f"\n\nPrevious Final Result: You must use this completed code as it is, "
                f"without making any modifications, to accomplish our task. "
                f"Previous Agent: {last_source if last_source else 'Unknown Agent'}"
            ) +
            (
                f"\n\nFinal code for {last_source if last_source else 'Unknown Agent'}:\n"
                f"{last_message}"
            )
        )
        return new_message


EventAgent = SocietyOfMindAgent(
    name="EventAgent",
    chat_manager=misty_event_manager,
    llm_config=llm_config,
    response_preparer=EventAgent_response_preparer,
)

# 如果需要对消息做 hook 处理，则注册 hook
EventAgent.register_hook("process_message_before_send", my_hook)
